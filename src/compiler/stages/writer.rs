use anyhow::{anyhow, bail, Context, Result};
use tracing::{debug, error};

use super::{IOMap, NodeMap, TypeMap, UpstreamTraversal};
use crate::graph::Type;

const SYS_MODULE: &str = include_str!("../python/sys.py");

pub fn write(
    debug_info: bool,
    node_map: NodeMap,
    io_map: IOMap,
    traversal: UpstreamTraversal,
) -> Result<String> {
    let exec_order = traversal.execution_order();

    let mut output = String::new();
    output.push_str(&format!(
        "# Generated by NodesOâ‚ƒ v{} (https://github.com/LeviLovie/NodesO3)\n\n",
        env!("CARGO_PKG_VERSION")
    ));

    output.push_str(SYS_MODULE);
    output.push('\n');

    for node_id in exec_order {
        if let Some(node) = node_map.get(*node_id) {
            let node_output = write_node(debug_info, node, &node_map, &io_map)
                .context(format!("Failed to write node {}", node.id))?;
            output.push_str(&node_output)
        } else {
            bail!("Node ID {} not found in NodeMap", node_id);
        }
    }

    Ok(output)
}

fn write_node(
    debug_info: bool,
    node: &crate::graph::Node,
    node_map: &NodeMap,
    io_map: &IOMap,
) -> Result<String> {
    let mut output = String::new();
    if debug_info {
        output.push_str(&format!("# Node {}#{}\n", node.desc.title, node.id));
    }

    let mut input_type_map: TypeMap<String> = TypeMap::new();

    let impl_desc = node.impl_for_lang("python3").ok_or_else(|| {
        anyhow!(
            "No Python3 implementation found for node {}#{}",
            node.desc.title,
            node.id
        )
    })?;
    let mut py_impl = format!(
        "{}{}",
        impl_desc.type_check.clone().unwrap_or(String::new()),
        impl_desc.code
    );
    replace(
        &mut py_impl,
        "{title}".to_string(),
        node.desc.title.to_string(),
    );
    replace(&mut py_impl, "{id}".to_string(), node.id.to_string());

    for (i, input) in node.desc.inputs.iter().enumerate() {
        if let Some(&(from_node, from_port)) = io_map.get((node.id, i)) {
            let from_data_type = if let Some(from_node) = node_map.get(from_node) {
                if let Some(from_port) = from_node.desc.outputs.get(from_port) {
                    from_port.data_type.clone()
                } else {
                    bail!(
                        "Output port {} of node {} not found",
                        from_port,
                        from_node.id
                    );
                }
            } else {
                bail!("Node ID {} not found in NodeMap", from_node);
            };
            let mut data_type = input.data_type.clone();

            match &data_type {
                Type::Inherit(inherited) => {
                    let inherited_type = if inherited.starts_with("ti_") {
                        let inherited_name = inherited.trim_start_matches("ti_");
                        input_type_map.print();
                        debug!(type_name = ?inherited_name, "Looking for type in input_type_map");
                        if let Some(t) = input_type_map.get(inherited_name.to_string()) {
                            Some(t.clone())
                        } else {
                            error!(
                                ?inherited,
                                "Inherited type is from an input but not found in InputTypeMap"
                            );
                            None
                        }
                    } else {
                        error!(?inherited, "Inherited type is not from an input or field");
                        None
                    };

                    if let Some(inherited_type) = &inherited_type {
                        input_type_map.set(input.name.clone(), inherited_type.clone());
                        data_type = inherited_type.clone();
                    } else {
                        error!("Type for inherited input was not found");
                    }
                }
                _ => {
                    input_type_map.set(input.name.clone(), from_data_type.clone());
                }
            }

            replace(
                &mut py_impl,
                format!("{{ti_{}}}", input.name),
                data_type.to_string(),
            );

            replace(
                &mut py_impl,
                format!("{{i_{}}}", input.name),
                format!("output_{}_{}", from_node, from_port),
            );
            continue;
        } else {
            bail!("Input {} of node {} is not connected", input.name, node.id);
        }
    }

    for field in &node.desc.fields {
        replace(
            &mut py_impl,
            format!("{{f_{}}}", field.name),
            field.value.to_string(),
        );
    }

    for (i, output) in node.desc.outputs.iter().enumerate() {
        replace(
            &mut py_impl,
            format!("{{o_{}}}", output.name),
            format!("output_{}_{}", node.id, i),
        );
    }

    output.push_str(&py_impl);
    output.push('\n');
    if debug_info {
        output.push('\n');
    }

    Ok(output)
}

fn replace(s: &mut String, from: String, to: String) {
    *s = s.replace(&from, &to);
}
